# APIs Documentation
## Authentication api

### Structure 

For the authentication API we have one table, `users_entity` that is represented by multiple parameters.

![](auth_db.png)

To get the documentation about the endpoints you can go on [http://localhost/auth/swagger-ui.html](http://localhost/auth/swagger-ui.html) when the topology is launched.

Once you are logged you receive a JWT to be able to make other call on API (add a user and update your password).

### Choices

1. For this API we only have 3 endpoint:

   - one for authentication
   - one to add a new user (only for admin users)
   - one to update his password

   We chose to expose only thews endpoint to be very strict. We have no utility yet to get the user informations or a list of all users, that's why we don't have a `get /users` or a `get /users/<mail>`.

2. To update the password we use the method `PATCH`. We chose this method because for an `user_entity` we will only change one properties and the payload of the request is identical for every requests (except the value of the password of cours).

3. To verify that the paylod given in the request is valid we implemented a kind of _reflexion_. For the class of the payload we get all _getter_ and then we apply them on the payload and we check that the result of the _getter_ method is not null or not empty.

   ```java
       /**
        * This method check that the payload is valid. A valid payload mean that
        * all value were given and that they were not empty
        * @param payload the payload that we want to test if it's valid
        * @param list the list with all getter of the payload's class
        * @return true is the payload is valid, false otherwise
        */
       private boolean checkPayloadIsValidImplementation(Object payload, List<Method> list) {
   
           Object object;
           for (Method method : list) {
               try {
                   object = method.invoke(payload);
                   if (object == null || object.toString().isEmpty()) {
                       return false;
                   }
               } catch (Exception e) {
                   return false;
               }
           }
           return true;
       }
   
       /**
        * This method will return the list of all getter of a class
        * @param c the class that we want to analyse
        * @return a list of method
        */
       public boolean checkPayloadIsValid(Class<?> c, Object payload) {
           ArrayList<Method> list = new ArrayList<>();
           Method[] methods = c.getDeclaredMethods();
           for (Method method : methods)
               if (isGetter(method))
                   list.add(method);
           return checkPayloadIsValidImplementation(payload, list);
       }
   ```

4. 

5. Our _ApiController_ delegate the work to a _buisiness_ class that will do all the logic, the controller will _catch_ errors throw by _buisiness_ and then get the code thrown and send it as a HTTP error code.

## Application api

### Structure

For the application API we have 3 tables : `magic_entity`, `unicorn_entity` and `unicorn_entity_magic_entities`. This last one is the table generated by the relation `ManyToMany` between `magic_entity` and `unicorn_entity`.

![](app_db.png)

To use this API you need to have a valid JWT given by the _authentication api_ 

### Choices